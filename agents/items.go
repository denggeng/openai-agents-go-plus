// Copyright 2025 The NLP Odyssey Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package agents

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/denggeng/openai-agents-go-plus/openaitypes"
	"github.com/denggeng/openai-agents-go-plus/usage"
	"github.com/openai/openai-go/v3/packages/param"
	"github.com/openai/openai-go/v3/responses"
	"github.com/openai/openai-go/v3/shared/constant"
)

// TResponseInputItem is a type alias for the ResponseInputItemUnionParam type from the OpenAI SDK.
type TResponseInputItem = responses.ResponseInputItemUnionParam

// TResponseOutputItem is a type alias for the ResponseOutputItemUnion type from the OpenAI SDK.
type TResponseOutputItem = responses.ResponseOutputItemUnion

// TResponseStreamEvent is a type alias for the ResponseStreamEventUnion type from the OpenAI SDK.
type TResponseStreamEvent = responses.ResponseStreamEventUnion

type ModelResponse struct {
	// A list of outputs (messages, tool calls, etc.) generated by the model
	Output []TResponseOutputItem `json:"output,omitempty"`

	// The usage information for the response.
	Usage *usage.Usage `json:"usage,omitempty"`

	// Optional ID for the response which can be used to refer to the response in subsequent calls to the
	// model. Not supported by all model providers.
	// If using OpenAI models via the Responses API, this is the `ResponseID` parameter, and it can
	// be passed to `Runner.Run`.
	ResponseID string `json:"response_id,omitempty"`

	// Optional request identifier returned by the model provider (for transport-level diagnostics).
	RequestID string `json:"request_id,omitempty"`
}

func (mr *ModelResponse) UnmarshalJSON(data []byte) error {
	type modelResponseAlias ModelResponse
	var decoded modelResponseAlias
	if err := json.Unmarshal(data, &decoded); err != nil {
		return err
	}
	*mr = ModelResponse(decoded)

	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	if mr.ResponseID == "" {
		if legacy, ok := raw["ResponseID"]; ok {
			if err := json.Unmarshal(legacy, &mr.ResponseID); err != nil {
				return fmt.Errorf("decode legacy ModelResponse.ResponseID: %w", err)
			}
		}
	}
	if mr.RequestID == "" {
		if legacy, ok := raw["RequestID"]; ok {
			if err := json.Unmarshal(legacy, &mr.RequestID); err != nil {
				return fmt.Errorf("decode legacy ModelResponse.RequestID: %w", err)
			}
		}
	}
	if len(mr.Output) == 0 {
		if legacy, ok := raw["Output"]; ok {
			if err := json.Unmarshal(legacy, &mr.Output); err != nil {
				return fmt.Errorf("decode legacy ModelResponse.Output: %w", err)
			}
		}
	}
	if mr.Usage == nil {
		if legacy, ok := raw["Usage"]; ok {
			var u usage.Usage
			if err := json.Unmarshal(legacy, &u); err != nil {
				return fmt.Errorf("decode legacy ModelResponse.Usage: %w", err)
			}
			mr.Usage = &u
		}
	}
	return nil
}

// ToInputItems converts the output into a list of input items suitable for passing to the model.
func (mr ModelResponse) ToInputItems() []TResponseInputItem {
	inputItems := make([]TResponseInputItem, len(mr.Output))
	for i, outputItem := range mr.Output {
		inputItems[i] = openaitypes.ResponseInputItemUnionParamFromResponseOutputItemUnion(outputItem)
	}
	return inputItems
}

type itemHelpers struct{}

func ItemHelpers() itemHelpers { return itemHelpers{} }

// ExtractLastContent extracts the last text content or refusal from a message.
func (itemHelpers) ExtractLastContent(message TResponseOutputItem) (string, error) {
	if message.Type != "message" || len(message.Content) == 0 {
		return "", nil
	}

	lastContent := message.Content[len(message.Content)-1]
	switch lastContent.Type {
	case "output_text":
		return lastContent.Text, nil
	case "refusal":
		return lastContent.Refusal, nil
	default:
		return "", ModelBehaviorErrorf("unexpected content type %q", lastContent.Type)
	}
}

// ExtractLastText extracts the last text content from a message, if any. Ignores refusals.
func (itemHelpers) ExtractLastText(message TResponseOutputItem) (string, bool) {
	if message.Type == "message" && len(message.Content) > 0 {
		lastContent := message.Content[len(message.Content)-1]
		if lastContent.Type == "output_text" {
			return lastContent.Text, true
		}
	}
	return "", false
}

// InputToNewInputList converts a string or list of input items into a list of input items.
func (itemHelpers) InputToNewInputList(input Input) []TResponseInputItem {
	switch v := input.(type) {
	case InputString:
		return []TResponseInputItem{
			{
				OfMessage: &responses.EasyInputMessageParam{
					Content: responses.EasyInputMessageContentUnionParam{
						OfString: param.NewOpt(v.String()),
					},
					Role: responses.EasyInputMessageRoleUser,
					Type: responses.EasyInputMessageTypeMessage,
				},
			},
		}
	case InputItems:
		return v.Copy()
	default:
		// This would be an unrecoverable implementation bug, so a panic is appropriate.
		panic(fmt.Errorf("unexpected Input type %T", v))
	}
}

// TextMessageOutputs concatenates all the text content from a list of message output items.
func (ih itemHelpers) TextMessageOutputs(items []RunItem) string {
	var sb strings.Builder
	for _, item := range items {
		if item, ok := item.(MessageOutputItem); ok {
			sb.WriteString(ih.TextMessageOutput(item))
		}
	}
	return sb.String()
}

// TextMessageOutput extracts all the text content from a single message output item.
func (itemHelpers) TextMessageOutput(message MessageOutputItem) string {
	var sb strings.Builder
	for _, item := range message.RawItem.Content {
		if item.Type == "output_text" {
			sb.WriteString(item.Text)
		}
	}
	return sb.String()
}

// ToolCallOutputItem creates a tool call output item from a tool call and its output.
func (itemHelpers) ToolCallOutputItem(
	toolCall ResponseFunctionToolCall,
	output any,
) responses.ResponseInputItemFunctionCallOutputParam {
	return responses.ResponseInputItemFunctionCallOutputParam{
		CallID: toolCall.CallID,
		Output: convertToolOutput(output),
		Type:   constant.ValueOf[constant.FunctionCallOutput](),
	}
}
